/* tslint:disable */
/* eslint-disable */
/**
 * PowerCards API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnkiFieldDto
 */
export interface AnkiFieldDto {
    /**
     * 
     * @type {string}
     * @memberof AnkiFieldDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnkiFieldDto
     */
    'ordinal'?: number;
}
/**
 * 
 * @export
 * @interface AnkiModelRequest
 */
export interface AnkiModelRequest {
    /**
     * 
     * @type {string}
     * @memberof AnkiModelRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelRequest
     */
    'css'?: string;
    /**
     * 
     * @type {Array<AnkiFieldDto>}
     * @memberof AnkiModelRequest
     */
    'fields'?: Array<AnkiFieldDto>;
    /**
     * 
     * @type {Array<AnkiTemplateDto>}
     * @memberof AnkiModelRequest
     */
    'templates'?: Array<AnkiTemplateDto>;
}
/**
 * 
 * @export
 * @interface AnkiModelResponse
 */
export interface AnkiModelResponse {
    /**
     * 
     * @type {number}
     * @memberof AnkiModelResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelResponse
     */
    'css'?: string;
    /**
     * 
     * @type {Array<AnkiFieldDto>}
     * @memberof AnkiModelResponse
     */
    'fields'?: Array<AnkiFieldDto>;
    /**
     * 
     * @type {Array<AnkiTemplateDto>}
     * @memberof AnkiModelResponse
     */
    'templates'?: Array<AnkiTemplateDto>;
}
/**
 * 
 * @export
 * @interface AnkiTemplateDto
 */
export interface AnkiTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'questionFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'answerFormat'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnkiTemplateDto
     */
    'ordinal'?: number;
}
/**
 * 
 * @export
 * @interface CardRequest
 */
export interface CardRequest {
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'noteId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'deckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'ordinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'queue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'due'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'easeFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'repetitions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'lapses'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'remainingSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'originalDue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'originalDeckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    'customData'?: string;
}
/**
 * 
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'noteId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'deckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'ordinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'queue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'due'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'easeFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'repetitions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'lapses'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'remainingSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'originalDue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'originalDeckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    'customData'?: string;
}
/**
 * 
 * @export
 * @interface DeckRequest
 */
export interface DeckRequest {
    /**
     * 
     * @type {string}
     * @memberof DeckRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DeckResponse
 */
export interface DeckResponse {
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeckResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NoteRequest
 */
export interface NoteRequest {
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'modelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'fields'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'sortField'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'checksum'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'customData'?: string;
}
/**
 * 
 * @export
 * @interface NoteResponse
 */
export interface NoteResponse {
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'modelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'fields'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'sortField'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'checksum'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'customData'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedResponseCardResponse
 */
export interface PaginatedResponseCardResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseCardResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<CardResponse>}
     * @memberof PaginatedResponseCardResponse
     */
    'data'?: Array<CardResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseDeckResponse
 */
export interface PaginatedResponseDeckResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseDeckResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<DeckResponse>}
     * @memberof PaginatedResponseDeckResponse
     */
    'data'?: Array<DeckResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseNoteResponse
 */
export interface PaginatedResponseNoteResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseNoteResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<NoteResponse>}
     * @memberof PaginatedResponseNoteResponse
     */
    'data'?: Array<NoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    'page'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    'nextPageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    'lastPageUri'?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}

/**
 * AnkiModelResourceApi - axios parameter creator
 * @export
 */
export const AnkiModelResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdDelete', 'id', id)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdGet', 'id', id)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdPut: async (id: number, ankiModelRequest: AnkiModelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdPut', 'id', id)
            // verify required parameter 'ankiModelRequest' is not null or undefined
            assertParamExists('v1ModelsIdPut', 'ankiModelRequest', ankiModelRequest)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ankiModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsPost: async (ankiModelRequest: AnkiModelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ankiModelRequest' is not null or undefined
            assertParamExists('v1ModelsPost', 'ankiModelRequest', ankiModelRequest)
            const localVarPath = `/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ankiModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnkiModelResourceApi - functional programming interface
 * @export
 */
export const AnkiModelResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnkiModelResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnkiModelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnkiModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnkiModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdPut(id, ankiModelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsPost(ankiModelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnkiModelResourceApi - factory interface
 * @export
 */
export const AnkiModelResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnkiModelResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<AnkiModelResponse>> {
            return localVarFp.v1ModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ModelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<AnkiModelResponse> {
            return localVarFp.v1ModelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnkiModelResponse> {
            return localVarFp.v1ModelsIdPut(id, ankiModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ModelsPost(ankiModelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnkiModelResourceApi - object-oriented interface
 * @export
 * @class AnkiModelResourceApi
 * @extends {BaseAPI}
 */
export class AnkiModelResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all Anki models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsGet(options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Anki model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an Anki model by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Anki model
     * @param {number} id 
     * @param {AnkiModelRequest} ankiModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdPut(id, ankiModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Anki model
     * @param {AnkiModelRequest} ankiModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsPost(ankiModelRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnkiResourceApi - axios parameter creator
 * @export
 */
export const AnkiResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiUploadPost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/anki/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnkiResourceApi - functional programming interface
 * @export
 */
export const AnkiResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnkiResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnkiUploadPost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnkiUploadPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiResourceApi.v1AnkiUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnkiResourceApi - factory interface
 * @export
 */
export const AnkiResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnkiResourceApiFp(configuration)
    return {
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiUploadPost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AnkiUploadPost(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnkiResourceApi - object-oriented interface
 * @export
 * @class AnkiResourceApi
 * @extends {BaseAPI}
 */
export class AnkiResourceApi extends BaseAPI {
    /**
     * Uploads an .apkg file and returns the loaded decks.
     * @summary Upload Anki package
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiResourceApi
     */
    public v1AnkiUploadPost(file?: File, options?: RawAxiosRequestConfig) {
        return AnkiResourceApiFp(this.configuration).v1AnkiUploadPost(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardResourceApi - axios parameter creator
 * @export
 */
export const CardResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all cards
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdDelete', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdGet', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdPut: async (id: number, cardRequest: CardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdPut', 'id', id)
            // verify required parameter 'cardRequest' is not null or undefined
            assertParamExists('v1CardsIdPut', 'cardRequest', cardRequest)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsPost: async (cardRequest: CardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardRequest' is not null or undefined
            assertParamExists('v1CardsPost', 'cardRequest', cardRequest)
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardResourceApi - functional programming interface
 * @export
 */
export const CardResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all cards
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdPut(id, cardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsPost(cardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardResourceApi - factory interface
 * @export
 */
export const CardResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all cards
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseCardResponse> {
            return localVarFp.v1CardsGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.v1CardsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.v1CardsIdPut(id, cardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsPost(cardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardResourceApi - object-oriented interface
 * @export
 * @class CardResourceApi
 * @extends {BaseAPI}
 */
export class CardResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all cards
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a card
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a card by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing card
     * @param {number} id 
     * @param {CardRequest} cardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdPut(id, cardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new card
     * @param {CardRequest} cardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsPost(cardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeckResourceApi - axios parameter creator
 * @export
 */
export const DeckResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/decks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdDelete', 'id', id)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdGet', 'id', id)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdPut: async (id: number, deckRequest: DeckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdPut', 'id', id)
            // verify required parameter 'deckRequest' is not null or undefined
            assertParamExists('v1DecksIdPut', 'deckRequest', deckRequest)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksPost: async (deckRequest: DeckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deckRequest' is not null or undefined
            assertParamExists('v1DecksPost', 'deckRequest', deckRequest)
            const localVarPath = `/v1/decks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeckResourceApi - functional programming interface
 * @export
 */
export const DeckResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeckResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseDeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdPut(id, deckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksPost(deckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeckResourceApi - factory interface
 * @export
 */
export const DeckResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeckResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseDeckResponse> {
            return localVarFp.v1DecksGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1DecksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DeckResponse> {
            return localVarFp.v1DecksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeckResponse> {
            return localVarFp.v1DecksIdPut(id, deckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1DecksPost(deckRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeckResourceApi - object-oriented interface
 * @export
 * @class DeckResourceApi
 * @extends {BaseAPI}
 */
export class DeckResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all decks
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a deck
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a deck by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdGet(id: number, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing deck
     * @param {number} id 
     * @param {DeckRequest} deckRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdPut(id, deckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new deck
     * @param {DeckRequest} deckRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksPost(deckRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NoteResourceApi - axios parameter creator
 * @export
 */
export const NoteResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all notes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdDelete', 'id', id)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdGet', 'id', id)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdPut: async (id: number, noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdPut', 'id', id)
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('v1NotesIdPut', 'noteRequest', noteRequest)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesPost: async (noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('v1NotesPost', 'noteRequest', noteRequest)
            const localVarPath = `/v1/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteResourceApi - functional programming interface
 * @export
 */
export const NoteResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoteResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all notes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdPut(id, noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesPost(noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NoteResourceApi - factory interface
 * @export
 */
export const NoteResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all notes
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseNoteResponse> {
            return localVarFp.v1NotesGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<NoteResponse> {
            return localVarFp.v1NotesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<NoteResponse> {
            return localVarFp.v1NotesIdPut(id, noteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesPost(noteRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoteResourceApi - object-oriented interface
 * @export
 * @class NoteResourceApi
 * @extends {BaseAPI}
 */
export class NoteResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all notes
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a note
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a note by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdGet(id: number, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing note
     * @param {number} id 
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdPut(id, noteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new note
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesPost(noteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagResourceApi - axios parameter creator
 * @export
 */
export const TagResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1TagsIdDelete', 'id', id)
            const localVarPath = `/v1/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsPost: async (tag: Tag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('v1TagsPost', 'tag', tag)
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagResourceApi - functional programming interface
 * @export
 */
export const TagResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsPost(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagResourceApi - factory interface
 * @export
 */
export const TagResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.v1TagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1TagsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1TagsPost(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagResourceApi - object-oriented interface
 * @export
 * @class TagResourceApi
 * @extends {BaseAPI}
 */
export class TagResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsGet(options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tag
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsPost(tag, options).then((request) => request(this.axios, this.basePath));
    }
}



