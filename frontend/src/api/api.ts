/* tslint:disable */
/* eslint-disable */
/**
 * PowerCards API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnkiFieldDto
 */
export interface AnkiFieldDto {
    /**
     * 
     * @type {string}
     * @memberof AnkiFieldDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnkiFieldDto
     */
    'ordinal'?: number;
}
/**
 * 
 * @export
 * @interface AnkiModelRequest
 */
export interface AnkiModelRequest {
    /**
     * 
     * @type {string}
     * @memberof AnkiModelRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelRequest
     */
    'css'?: string;
    /**
     * 
     * @type {Array<AnkiFieldDto>}
     * @memberof AnkiModelRequest
     */
    'fields'?: Array<AnkiFieldDto>;
    /**
     * 
     * @type {Array<AnkiTemplateDto>}
     * @memberof AnkiModelRequest
     */
    'templates'?: Array<AnkiTemplateDto>;
}
/**
 * 
 * @export
 * @interface AnkiModelResponse
 */
export interface AnkiModelResponse {
    /**
     * 
     * @type {number}
     * @memberof AnkiModelResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiModelResponse
     */
    'css'?: string;
    /**
     * 
     * @type {Array<AnkiFieldDto>}
     * @memberof AnkiModelResponse
     */
    'fields'?: Array<AnkiFieldDto>;
    /**
     * 
     * @type {Array<AnkiTemplateDto>}
     * @memberof AnkiModelResponse
     */
    'templates'?: Array<AnkiTemplateDto>;
}
/**
 * 
 * @export
 * @interface AnkiTemplateDto
 */
export interface AnkiTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'questionFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnkiTemplateDto
     */
    'answerFormat'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnkiTemplateDto
     */
    'ordinal'?: number;
}
/**
 * 
 * @export
 * @interface BatchEnhanceRequest
 */
export interface BatchEnhanceRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof BatchEnhanceRequest
     */
    'noteIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface BulkDeleteRequest
 */
export interface BulkDeleteRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkDeleteRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface BulkMoveNoteRequest
 */
export interface BulkMoveNoteRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkMoveNoteRequest
     */
    'noteIds'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof BulkMoveNoteRequest
     */
    'targetDeckId'?: number;
}
/**
 * 
 * @export
 * @interface BulkMoveRequest
 */
export interface BulkMoveRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkMoveRequest
     */
    'cardIds'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof BulkMoveRequest
     */
    'targetDeckId'?: number;
}
/**
 * 
 * @export
 * @interface BulkTagRequest
 */
export interface BulkTagRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkTagRequest
     */
    'noteIds'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkTagRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CardRequest
 */
export interface CardRequest {
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'noteId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'deckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'ordinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'queue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'due'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'easeFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'repetitions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'lapses'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'remainingSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'originalDue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'originalDeckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    'customData'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    'noteContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    'noteTags'?: string;
}
/**
 * 
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'noteId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'deckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'ordinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'queue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'due'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'easeFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'repetitions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'lapses'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'remainingSteps'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'originalDue'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'originalDeckId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    'customData'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    'noteField'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    'noteTags'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardResponse
     */
    'isDraft'?: boolean;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChatHistory
 */
export interface ChatHistory {
    /**
     * 
     * @type {string}
     * @memberof ChatHistory
     */
    'id'?: string;
    /**
     * 
     * @type {Chat}
     * @memberof ChatHistory
     */
    'chat'?: Chat;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory
     */
    'messageType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface DeckRequest
 */
export interface DeckRequest {
    /**
     * 
     * @type {string}
     * @memberof DeckRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DeckResponse
 */
export interface DeckResponse {
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeckResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'cardCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'newCards'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'learningCards'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'reviewCards'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'dueCards'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'totalCards'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeckResponse
     */
    'lastStudied'?: number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface NoteRequest
 */
export interface NoteRequest {
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'modelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'fields'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'sortField'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'checksum'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'customData'?: string;
}
/**
 * 
 * @export
 * @interface NoteResponse
 */
export interface NoteResponse {
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'modelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'modificationTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'updateSequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'fields'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'sortField'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'checksum'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoteResponse
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteResponse
     */
    'customData'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NoteResponse
     */
    'isDraft'?: boolean;
}
/**
 * 
 * @export
 * @interface PaginatedResponseCardResponse
 */
export interface PaginatedResponseCardResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseCardResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<CardResponse>}
     * @memberof PaginatedResponseCardResponse
     */
    'data'?: Array<CardResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseDeckResponse
 */
export interface PaginatedResponseDeckResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseDeckResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<DeckResponse>}
     * @memberof PaginatedResponseDeckResponse
     */
    'data'?: Array<DeckResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseNoteResponse
 */
export interface PaginatedResponseNoteResponse {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseNoteResponse
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<NoteResponse>}
     * @memberof PaginatedResponseNoteResponse
     */
    'data'?: Array<NoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedResponseTagStats
 */
export interface PaginatedResponseTagStats {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginatedResponseTagStats
     */
    'pagination'?: PaginationMeta;
    /**
     * 
     * @type {Array<TagStats>}
     * @memberof PaginatedResponseTagStats
     */
    'data'?: Array<TagStats>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    'page'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    'nextPageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    'lastPageUri'?: string;
}
/**
 * 
 * @export
 * @interface ProfileRequest
 */
export interface ProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'colorPalette'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileRequest
     */
    'darkMode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'aiProvider'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'aiApiKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileRequest
     */
    'preferences'?: string;
}
/**
 * 
 * @export
 * @interface ProfileResponse
 */
export interface ProfileResponse {
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'keycloakId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'bannerUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'colorPalette'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'darkMode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'aiProvider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'hasAiApiKey'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'preferences'?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {Workspace}
     * @memberof Tag
     */
    'workspace'?: Workspace;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TagStats
 */
export interface TagStats {
    /**
     * 
     * @type {number}
     * @memberof TagStats
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TagStats
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TagStats
     */
    'noteCount'?: number;
}
/**
 * 
 * @export
 * @interface UserRegistrationRequest
 */
export interface UserRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {number}
     * @memberof Workspace
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface WorkspaceRequest
 */
export interface WorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface WorkspaceResponse
 */
export interface WorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'name'?: string;
}

/**
 * AIResourceApi - axios parameter creator
 * @export
 */
export const AIResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Chat
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiChatPost: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1AiChatPost', 'body', body)
            const localVarPath = `/v1/ai/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enhance Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiEnhanceModelPost: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('v1AiEnhanceModelPost', 'requestBody', requestBody)
            const localVarPath = `/v1/ai/enhance-model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test Connection
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiTestPost: async (requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('v1AiTestPost', 'requestBody', requestBody)
            const localVarPath = `/v1/ai/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIResourceApi - functional programming interface
 * @export
 */
export const AIResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Chat
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AiChatPost(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AiChatPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIResourceApi.v1AiChatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Enhance Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AiEnhanceModelPost(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AiEnhanceModelPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIResourceApi.v1AiEnhanceModelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test Connection
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AiTestPost(requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AiTestPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIResourceApi.v1AiTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIResourceApi - factory interface
 * @export
 */
export const AIResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Chat
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiChatPost(body: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.v1AiChatPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enhance Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiEnhanceModelPost(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AiEnhanceModelPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test Connection
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiTestPost(requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AiTestPost(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIResourceApi - object-oriented interface
 * @export
 * @class AIResourceApi
 * @extends {BaseAPI}
 */
export class AIResourceApi extends BaseAPI {
    /**
     * 
     * @summary Chat
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIResourceApi
     */
    public v1AiChatPost(body: string, options?: RawAxiosRequestConfig) {
        return AIResourceApiFp(this.configuration).v1AiChatPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enhance Model
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIResourceApi
     */
    public v1AiEnhanceModelPost(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return AIResourceApiFp(this.configuration).v1AiEnhanceModelPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test Connection
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIResourceApi
     */
    public v1AiTestPost(requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return AIResourceApiFp(this.configuration).v1AiTestPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnkiModelResourceApi - axios parameter creator
 * @export
 */
export const AnkiModelResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdDelete', 'id', id)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdGet', 'id', id)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdPut: async (id: number, ankiModelRequest: AnkiModelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ModelsIdPut', 'id', id)
            // verify required parameter 'ankiModelRequest' is not null or undefined
            assertParamExists('v1ModelsIdPut', 'ankiModelRequest', ankiModelRequest)
            const localVarPath = `/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ankiModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsPost: async (ankiModelRequest: AnkiModelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ankiModelRequest' is not null or undefined
            assertParamExists('v1ModelsPost', 'ankiModelRequest', ankiModelRequest)
            const localVarPath = `/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ankiModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnkiModelResourceApi - functional programming interface
 * @export
 */
export const AnkiModelResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnkiModelResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnkiModelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnkiModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnkiModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsIdPut(id, ankiModelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ModelsPost(ankiModelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiModelResourceApi.v1ModelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnkiModelResourceApi - factory interface
 * @export
 */
export const AnkiModelResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnkiModelResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Anki models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<AnkiModelResponse>> {
            return localVarFp.v1ModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Anki model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ModelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an Anki model by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<AnkiModelResponse> {
            return localVarFp.v1ModelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Anki model
         * @param {number} id 
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnkiModelResponse> {
            return localVarFp.v1ModelsIdPut(id, ankiModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Anki model
         * @param {AnkiModelRequest} ankiModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ModelsPost(ankiModelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnkiModelResourceApi - object-oriented interface
 * @export
 * @class AnkiModelResourceApi
 * @extends {BaseAPI}
 */
export class AnkiModelResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all Anki models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsGet(options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Anki model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an Anki model by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Anki model
     * @param {number} id 
     * @param {AnkiModelRequest} ankiModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsIdPut(id: number, ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsIdPut(id, ankiModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Anki model
     * @param {AnkiModelRequest} ankiModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiModelResourceApi
     */
    public v1ModelsPost(ankiModelRequest: AnkiModelRequest, options?: RawAxiosRequestConfig) {
        return AnkiModelResourceApiFp(this.configuration).v1ModelsPost(ankiModelRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnkiResourceApi - axios parameter creator
 * @export
 */
export const AnkiResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports selected decks to an .apkg file.
         * @summary Export Anki package
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiExportPost: async (requestBody: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('v1AnkiExportPost', 'requestBody', requestBody)
            const localVarPath = `/v1/anki/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiUploadPost: async (file?: File, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/anki/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (force !== undefined) { 
                localVarFormParams.append('force', String(force) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnkiResourceApi - functional programming interface
 * @export
 */
export const AnkiResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnkiResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports selected decks to an .apkg file.
         * @summary Export Anki package
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnkiExportPost(requestBody: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnkiExportPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiResourceApi.v1AnkiExportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnkiUploadPost(file?: File, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnkiUploadPost(file, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnkiResourceApi.v1AnkiUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnkiResourceApi - factory interface
 * @export
 */
export const AnkiResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnkiResourceApiFp(configuration)
    return {
        /**
         * Exports selected decks to an .apkg file.
         * @summary Export Anki package
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiExportPost(requestBody: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AnkiExportPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an .apkg file and returns the loaded decks.
         * @summary Upload Anki package
         * @param {File} [file] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnkiUploadPost(file?: File, force?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AnkiUploadPost(file, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnkiResourceApi - object-oriented interface
 * @export
 * @class AnkiResourceApi
 * @extends {BaseAPI}
 */
export class AnkiResourceApi extends BaseAPI {
    /**
     * Exports selected decks to an .apkg file.
     * @summary Export Anki package
     * @param {Array<number>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiResourceApi
     */
    public v1AnkiExportPost(requestBody: Array<number>, options?: RawAxiosRequestConfig) {
        return AnkiResourceApiFp(this.configuration).v1AnkiExportPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an .apkg file and returns the loaded decks.
     * @summary Upload Anki package
     * @param {File} [file] 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnkiResourceApi
     */
    public v1AnkiUploadPost(file?: File, force?: boolean, options?: RawAxiosRequestConfig) {
        return AnkiResourceApiFp(this.configuration).v1AnkiUploadPost(file, force, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthResourceApi - axios parameter creator
 * @export
 */
export const AuthResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('v1AuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshPost: async (refreshToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshToken !== undefined) {
                localVarQueryParameter['refresh_token'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRegisterPost: async (userRegistrationRequest: UserRegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegistrationRequest' is not null or undefined
            assertParamExists('v1AuthRegisterPost', 'userRegistrationRequest', userRegistrationRequest)
            const localVarPath = `/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthResourceApi - functional programming interface
 * @export
 */
export const AuthResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthResourceApi.v1AuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthRefreshPost(refreshToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthRefreshPost(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthResourceApi.v1AuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthRegisterPost(userRegistrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthResourceApi.v1AuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthResourceApi - factory interface
 * @export
 */
export const AuthResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshPost(refreshToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AuthRefreshPost(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1AuthRegisterPost(userRegistrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthResourceApi - object-oriented interface
 * @export
 * @class AuthResourceApi
 * @extends {BaseAPI}
 */
export class AuthResourceApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthResourceApi
     */
    public v1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthResourceApiFp(this.configuration).v1AuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthResourceApi
     */
    public v1AuthRefreshPost(refreshToken?: string, options?: RawAxiosRequestConfig) {
        return AuthResourceApiFp(this.configuration).v1AuthRefreshPost(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {UserRegistrationRequest} userRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthResourceApi
     */
    public v1AuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig) {
        return AuthResourceApiFp(this.configuration).v1AuthRegisterPost(userRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardResourceApi - axios parameter creator
 * @export
 */
export const CardResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bulk delete cards
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsBulkDeletePost: async (bulkDeleteRequest: BulkDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDeleteRequest' is not null or undefined
            assertParamExists('v1CardsBulkDeletePost', 'bulkDeleteRequest', bulkDeleteRequest)
            const localVarPath = `/v1/cards/bulk/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk move cards to deck
         * @param {BulkMoveRequest} bulkMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsBulkMovePost: async (bulkMoveRequest: BulkMoveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkMoveRequest' is not null or undefined
            assertParamExists('v1CardsBulkMovePost', 'bulkMoveRequest', bulkMoveRequest)
            const localVarPath = `/v1/cards/bulk/move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkMoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all cards
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsGet: async (deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deckId !== undefined) {
                localVarQueryParameter['deckId'] = deckId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdDelete', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdGet', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdPut: async (id: number, cardRequest: CardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CardsIdPut', 'id', id)
            // verify required parameter 'cardRequest' is not null or undefined
            assertParamExists('v1CardsIdPut', 'cardRequest', cardRequest)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsPost: async (cardRequest: CardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardRequest' is not null or undefined
            assertParamExists('v1CardsPost', 'cardRequest', cardRequest)
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardResourceApi - functional programming interface
 * @export
 */
export const CardResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bulk delete cards
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsBulkDeletePost(bulkDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsBulkDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk move cards to deck
         * @param {BulkMoveRequest} bulkMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsBulkMovePost(bulkMoveRequest: BulkMoveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsBulkMovePost(bulkMoveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsBulkMovePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all cards
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsGet(deckId, page, perPage, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsIdPut(id, cardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CardsPost(cardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardResourceApi.v1CardsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardResourceApi - factory interface
 * @export
 */
export const CardResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Bulk delete cards
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsBulkDeletePost(bulkDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk move cards to deck
         * @param {BulkMoveRequest} bulkMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsBulkMovePost(bulkMoveRequest: BulkMoveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsBulkMovePost(bulkMoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all cards
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseCardResponse> {
            return localVarFp.v1CardsGet(deckId, page, perPage, search, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a card
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a card by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.v1CardsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing card
         * @param {number} id 
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.v1CardsIdPut(id, cardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new card
         * @param {CardRequest} cardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CardsPost(cardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardResourceApi - object-oriented interface
 * @export
 * @class CardResourceApi
 * @extends {BaseAPI}
 */
export class CardResourceApi extends BaseAPI {
    /**
     * 
     * @summary Bulk delete cards
     * @param {BulkDeleteRequest} bulkDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsBulkDeletePost(bulkDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk move cards to deck
     * @param {BulkMoveRequest} bulkMoveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsBulkMovePost(bulkMoveRequest: BulkMoveRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsBulkMovePost(bulkMoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all cards
     * @param {number} [deckId] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [search] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsGet(deckId, page, perPage, search, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a card
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a card by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing card
     * @param {number} id 
     * @param {CardRequest} cardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsIdPut(id: number, cardRequest: CardRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsIdPut(id, cardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new card
     * @param {CardRequest} cardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardResourceApi
     */
    public v1CardsPost(cardRequest: CardRequest, options?: RawAxiosRequestConfig) {
        return CardResourceApiFp(this.configuration).v1CardsPost(cardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatResourceApi - axios parameter creator
 * @export
 */
export const ChatResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Chats
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsGet: async (xWorkspaceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xWorkspaceId != null) {
                localVarHeaderParameter['X-Workspace-Id'] = String(xWorkspaceId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Chat
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatsIdDelete', 'id', id)
            const localVarPath = `/v1/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get History
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdHistoryGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatsIdHistoryGet', 'id', id)
            const localVarPath = `/v1/chats/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send Message
         * @param {string} id 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdMessagesPost: async (id: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatsIdMessagesPost', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ChatsIdMessagesPost', 'body', body)
            const localVarPath = `/v1/chats/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Chat
         * @param {Chat} chat 
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsPost: async (chat: Chat, xWorkspaceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chat' is not null or undefined
            assertParamExists('v1ChatsPost', 'chat', chat)
            const localVarPath = `/v1/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xWorkspaceId != null) {
                localVarHeaderParameter['X-Workspace-Id'] = String(xWorkspaceId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chat, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatResourceApi - functional programming interface
 * @export
 */
export const ChatResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Chats
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatsGet(xWorkspaceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatsGet(xWorkspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatResourceApi.v1ChatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Chat
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatResourceApi.v1ChatsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get History
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatsIdHistoryGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatsIdHistoryGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatResourceApi.v1ChatsIdHistoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send Message
         * @param {string} id 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatsIdMessagesPost(id: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatsIdMessagesPost(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatResourceApi.v1ChatsIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Chat
         * @param {Chat} chat 
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatsPost(chat: Chat, xWorkspaceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatsPost(chat, xWorkspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatResourceApi.v1ChatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatResourceApi - factory interface
 * @export
 */
export const ChatResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List Chats
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsGet(xWorkspaceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Chat>> {
            return localVarFp.v1ChatsGet(xWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Chat
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1ChatsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get History
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdHistoryGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChatHistory>> {
            return localVarFp.v1ChatsIdHistoryGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send Message
         * @param {string} id 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsIdMessagesPost(id: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1ChatsIdMessagesPost(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Chat
         * @param {Chat} chat 
         * @param {string} [xWorkspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatsPost(chat: Chat, xWorkspaceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Chat> {
            return localVarFp.v1ChatsPost(chat, xWorkspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatResourceApi - object-oriented interface
 * @export
 * @class ChatResourceApi
 * @extends {BaseAPI}
 */
export class ChatResourceApi extends BaseAPI {
    /**
     * 
     * @summary List Chats
     * @param {string} [xWorkspaceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatResourceApi
     */
    public v1ChatsGet(xWorkspaceId?: string, options?: RawAxiosRequestConfig) {
        return ChatResourceApiFp(this.configuration).v1ChatsGet(xWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Chat
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatResourceApi
     */
    public v1ChatsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ChatResourceApiFp(this.configuration).v1ChatsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get History
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatResourceApi
     */
    public v1ChatsIdHistoryGet(id: string, options?: RawAxiosRequestConfig) {
        return ChatResourceApiFp(this.configuration).v1ChatsIdHistoryGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send Message
     * @param {string} id 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatResourceApi
     */
    public v1ChatsIdMessagesPost(id: string, body: string, options?: RawAxiosRequestConfig) {
        return ChatResourceApiFp(this.configuration).v1ChatsIdMessagesPost(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Chat
     * @param {Chat} chat 
     * @param {string} [xWorkspaceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatResourceApi
     */
    public v1ChatsPost(chat: Chat, xWorkspaceId?: string, options?: RawAxiosRequestConfig) {
        return ChatResourceApiFp(this.configuration).v1ChatsPost(chat, xWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeckResourceApi - axios parameter creator
 * @export
 */
export const DeckResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksGet: async (page?: number, perPage?: number, search?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/decks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdDelete', 'id', id)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdGet', 'id', id)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdPut: async (id: number, deckRequest: DeckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DecksIdPut', 'id', id)
            // verify required parameter 'deckRequest' is not null or undefined
            assertParamExists('v1DecksIdPut', 'deckRequest', deckRequest)
            const localVarPath = `/v1/decks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksPost: async (deckRequest: DeckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deckRequest' is not null or undefined
            assertParamExists('v1DecksPost', 'deckRequest', deckRequest)
            const localVarPath = `/v1/decks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeckResourceApi - functional programming interface
 * @export
 */
export const DeckResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeckResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksGet(page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseDeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksGet(page, perPage, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksIdPut(id, deckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DecksPost(deckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeckResourceApi.v1DecksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeckResourceApi - factory interface
 * @export
 */
export const DeckResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeckResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List all decks
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksGet(page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseDeckResponse> {
            return localVarFp.v1DecksGet(page, perPage, search, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a deck
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1DecksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a deck by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DeckResponse> {
            return localVarFp.v1DecksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing deck
         * @param {number} id 
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeckResponse> {
            return localVarFp.v1DecksIdPut(id, deckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new deck
         * @param {DeckRequest} deckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1DecksPost(deckRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeckResourceApi - object-oriented interface
 * @export
 * @class DeckResourceApi
 * @extends {BaseAPI}
 */
export class DeckResourceApi extends BaseAPI {
    /**
     * 
     * @summary List all decks
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [search] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksGet(page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksGet(page, perPage, search, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a deck
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a deck by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdGet(id: number, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing deck
     * @param {number} id 
     * @param {DeckRequest} deckRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksIdPut(id: number, deckRequest: DeckRequest, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksIdPut(id, deckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new deck
     * @param {DeckRequest} deckRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeckResourceApi
     */
    public v1DecksPost(deckRequest: DeckRequest, options?: RawAxiosRequestConfig) {
        return DeckResourceApiFp(this.configuration).v1DecksPost(deckRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NoteResourceApi - axios parameter creator
 * @export
 */
export const NoteResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bulk delete notes
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkDeletePost: async (bulkDeleteRequest: BulkDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDeleteRequest' is not null or undefined
            assertParamExists('v1NotesBulkDeletePost', 'bulkDeleteRequest', bulkDeleteRequest)
            const localVarPath = `/v1/notes/bulk/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch enhance notes using AI
         * @param {BatchEnhanceRequest} batchEnhanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkEnhancePost: async (batchEnhanceRequest: BatchEnhanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchEnhanceRequest' is not null or undefined
            assertParamExists('v1NotesBulkEnhancePost', 'batchEnhanceRequest', batchEnhanceRequest)
            const localVarPath = `/v1/notes/bulk/enhance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchEnhanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk move notes (cards) to deck
         * @param {BulkMoveNoteRequest} bulkMoveNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkMovePost: async (bulkMoveNoteRequest: BulkMoveNoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkMoveNoteRequest' is not null or undefined
            assertParamExists('v1NotesBulkMovePost', 'bulkMoveNoteRequest', bulkMoveNoteRequest)
            const localVarPath = `/v1/notes/bulk/move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkMoveNoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk add tags to notes
         * @param {BulkTagRequest} bulkTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkTagsPost: async (bulkTagRequest: BulkTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTagRequest' is not null or undefined
            assertParamExists('v1NotesBulkTagsPost', 'bulkTagRequest', bulkTagRequest)
            const localVarPath = `/v1/notes/bulk/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all notes
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesGet: async (deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deckId !== undefined) {
                localVarQueryParameter['deckId'] = deckId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdDelete', 'id', id)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discard a note draft
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDraftDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdDraftDelete', 'id', id)
            const localVarPath = `/v1/notes/{id}/draft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save a draft for a note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDraftPost: async (id: number, noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdDraftPost', 'id', id)
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('v1NotesIdDraftPost', 'noteRequest', noteRequest)
            const localVarPath = `/v1/notes/{id}/draft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {boolean} [draft] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdGet: async (id: number, draft?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdGet', 'id', id)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload media for a note
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdMediaPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdMediaPost', 'id', id)
            const localVarPath = `/v1/notes/{id}/media`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdPut: async (id: number, noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotesIdPut', 'id', id)
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('v1NotesIdPut', 'noteRequest', noteRequest)
            const localVarPath = `/v1/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesPost: async (noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('v1NotesPost', 'noteRequest', noteRequest)
            const localVarPath = `/v1/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteResourceApi - functional programming interface
 * @export
 */
export const NoteResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoteResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bulk delete notes
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesBulkDeletePost(bulkDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesBulkDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Batch enhance notes using AI
         * @param {BatchEnhanceRequest} batchEnhanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesBulkEnhancePost(batchEnhanceRequest: BatchEnhanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesBulkEnhancePost(batchEnhanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesBulkEnhancePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk move notes (cards) to deck
         * @param {BulkMoveNoteRequest} bulkMoveNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesBulkMovePost(bulkMoveNoteRequest: BulkMoveNoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesBulkMovePost(bulkMoveNoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesBulkMovePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk add tags to notes
         * @param {BulkTagRequest} bulkTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesBulkTagsPost(bulkTagRequest: BulkTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesBulkTagsPost(bulkTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesBulkTagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all notes
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesGet(deckId, page, perPage, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Discard a note draft
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdDraftDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdDraftDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdDraftDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Save a draft for a note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdDraftPost(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdDraftPost(id, noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdDraftPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {boolean} [draft] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdGet(id: number, draft?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdGet(id, draft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload media for a note
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdMediaPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdMediaPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdMediaPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesIdPut(id, noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotesPost(noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoteResourceApi.v1NotesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NoteResourceApi - factory interface
 * @export
 */
export const NoteResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Bulk delete notes
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesBulkDeletePost(bulkDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch enhance notes using AI
         * @param {BatchEnhanceRequest} batchEnhanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkEnhancePost(batchEnhanceRequest: BatchEnhanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesBulkEnhancePost(batchEnhanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk move notes (cards) to deck
         * @param {BulkMoveNoteRequest} bulkMoveNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkMovePost(bulkMoveNoteRequest: BulkMoveNoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesBulkMovePost(bulkMoveNoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk add tags to notes
         * @param {BulkTagRequest} bulkTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesBulkTagsPost(bulkTagRequest: BulkTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesBulkTagsPost(bulkTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all notes
         * @param {number} [deckId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseNoteResponse> {
            return localVarFp.v1NotesGet(deckId, page, perPage, search, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a note
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discard a note draft
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDraftDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesIdDraftDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save a draft for a note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdDraftPost(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesIdDraftPost(id, noteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note by ID
         * @param {number} id 
         * @param {boolean} [draft] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdGet(id: number, draft?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<NoteResponse> {
            return localVarFp.v1NotesIdGet(id, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload media for a note
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdMediaPost(id: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1NotesIdMediaPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing note
         * @param {number} id 
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<NoteResponse> {
            return localVarFp.v1NotesIdPut(id, noteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new note
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotesPost(noteRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoteResourceApi - object-oriented interface
 * @export
 * @class NoteResourceApi
 * @extends {BaseAPI}
 */
export class NoteResourceApi extends BaseAPI {
    /**
     * 
     * @summary Bulk delete notes
     * @param {BulkDeleteRequest} bulkDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesBulkDeletePost(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesBulkDeletePost(bulkDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch enhance notes using AI
     * @param {BatchEnhanceRequest} batchEnhanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesBulkEnhancePost(batchEnhanceRequest: BatchEnhanceRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesBulkEnhancePost(batchEnhanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk move notes (cards) to deck
     * @param {BulkMoveNoteRequest} bulkMoveNoteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesBulkMovePost(bulkMoveNoteRequest: BulkMoveNoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesBulkMovePost(bulkMoveNoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk add tags to notes
     * @param {BulkTagRequest} bulkTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesBulkTagsPost(bulkTagRequest: BulkTagRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesBulkTagsPost(bulkTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all notes
     * @param {number} [deckId] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [search] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesGet(deckId?: number, page?: number, perPage?: number, search?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesGet(deckId, page, perPage, search, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a note
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discard a note draft
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdDraftDelete(id: number, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdDraftDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save a draft for a note
     * @param {number} id 
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdDraftPost(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdDraftPost(id, noteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a note by ID
     * @param {number} id 
     * @param {boolean} [draft] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdGet(id: number, draft?: boolean, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdGet(id, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload media for a note
     * @param {number} id 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdMediaPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdMediaPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing note
     * @param {number} id 
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesIdPut(id: number, noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesIdPut(id, noteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new note
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteResourceApi
     */
    public v1NotesPost(noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return NoteResourceApiFp(this.configuration).v1NotesPost(noteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileResourceApi - axios parameter creator
 * @export
 */
export const ProfileResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload Avatar
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileAvatarPost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/profile/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Banner
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileBannerPost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/profile/banner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Profile
         * @param {ProfileRequest} profileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePut: async (profileRequest: ProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileRequest' is not null or undefined
            assertParamExists('v1ProfilePut', 'profileRequest', profileRequest)
            const localVarPath = `/v1/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileResourceApi - functional programming interface
 * @export
 */
export const ProfileResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload Avatar
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileAvatarPost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileAvatarPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileResourceApi.v1ProfileAvatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Banner
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileBannerPost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileBannerPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileResourceApi.v1ProfileBannerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileResourceApi.v1ProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Profile
         * @param {ProfileRequest} profileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfilePut(profileRequest: ProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfilePut(profileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileResourceApi.v1ProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileResourceApi - factory interface
 * @export
 */
export const ProfileResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload Avatar
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileAvatarPost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.v1ProfileAvatarPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Banner
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileBannerPost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.v1ProfileBannerPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.v1ProfileGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Profile
         * @param {ProfileRequest} profileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePut(profileRequest: ProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.v1ProfilePut(profileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileResourceApi - object-oriented interface
 * @export
 * @class ProfileResourceApi
 * @extends {BaseAPI}
 */
export class ProfileResourceApi extends BaseAPI {
    /**
     * 
     * @summary Upload Avatar
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileResourceApi
     */
    public v1ProfileAvatarPost(file?: File, options?: RawAxiosRequestConfig) {
        return ProfileResourceApiFp(this.configuration).v1ProfileAvatarPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Banner
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileResourceApi
     */
    public v1ProfileBannerPost(file?: File, options?: RawAxiosRequestConfig) {
        return ProfileResourceApiFp(this.configuration).v1ProfileBannerPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileResourceApi
     */
    public v1ProfileGet(options?: RawAxiosRequestConfig) {
        return ProfileResourceApiFp(this.configuration).v1ProfileGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Profile
     * @param {ProfileRequest} profileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileResourceApi
     */
    public v1ProfilePut(profileRequest: ProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfileResourceApiFp(this.configuration).v1ProfilePut(profileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagResourceApi - axios parameter creator
 * @export
 */
export const TagResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List tags
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsGet: async (search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1TagsIdDelete', 'id', id)
            const localVarPath = `/v1/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsPost: async (tag: Tag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('v1TagsPost', 'tag', tag)
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tags with stats
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsStatsGet: async (page?: number, perPage?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagResourceApi - functional programming interface
 * @export
 */
export const TagResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List tags
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsGet(search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsGet(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsPost(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tags with stats
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TagsStatsGet(page?: number, perPage?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseTagStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TagsStatsGet(page, perPage, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagResourceApi.v1TagsStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagResourceApi - factory interface
 * @export
 */
export const TagResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List tags
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsGet(search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.v1TagsGet(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1TagsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tag
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1TagsPost(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tags with stats
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TagsStatsGet(page?: number, perPage?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseTagStats> {
            return localVarFp.v1TagsStatsGet(page, perPage, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagResourceApi - object-oriented interface
 * @export
 * @class TagResourceApi
 * @extends {BaseAPI}
 */
export class TagResourceApi extends BaseAPI {
    /**
     * 
     * @summary List tags
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsGet(search?: string, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsGet(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tag
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsPost(tag: Tag, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsPost(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tags with stats
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagResourceApi
     */
    public v1TagsStatsGet(page?: number, perPage?: number, search?: string, options?: RawAxiosRequestConfig) {
        return TagResourceApiFp(this.configuration).v1TagsStatsGet(page, perPage, search, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceResourceApi - axios parameter creator
 * @export
 */
export const WorkspaceResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1WorkspacesIdDelete', 'id', id)
            const localVarPath = `/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesPost: async (workspaceRequest: WorkspaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceRequest' is not null or undefined
            assertParamExists('v1WorkspacesPost', 'workspaceRequest', workspaceRequest)
            const localVarPath = `/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceResourceApi - functional programming interface
 * @export
 */
export const WorkspaceResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WorkspacesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WorkspacesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.v1WorkspacesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WorkspacesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WorkspacesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.v1WorkspacesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1WorkspacesPost(workspaceRequest: WorkspaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1WorkspacesPost(workspaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.v1WorkspacesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceResourceApi - factory interface
 * @export
 */
export const WorkspaceResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceResponse>> {
            return localVarFp.v1WorkspacesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1WorkspacesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1WorkspacesPost(workspaceRequest: WorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.v1WorkspacesPost(workspaceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceResourceApi - object-oriented interface
 * @export
 * @class WorkspaceResourceApi
 * @extends {BaseAPI}
 */
export class WorkspaceResourceApi extends BaseAPI {
    /**
     * 
     * @summary List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public v1WorkspacesGet(options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).v1WorkspacesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public v1WorkspacesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).v1WorkspacesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create
     * @param {WorkspaceRequest} workspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public v1WorkspacesPost(workspaceRequest: WorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).v1WorkspacesPost(workspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



